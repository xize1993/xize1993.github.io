[{"title":"用IDEA Community和Docker构建Spring Boot开发环境","url":"/2020/05/16/20200516_spring_docker_debug/","content":"\n## 写在前面\n前阵子开始学习Docker，容器化确实是很方便很有魅力的技术，因为在工作中并没有用到，便想着能不能在自己的日常开发中使用学习。\n\n实践上的话第一个想到的还是用来构建开发环境吧，不同于其他发行版多的语言，Java开发环境中JDK还是比较少变化的（当然前两年开始半年发布一个大版本了），而且Java是编译型语言，在将Docker运用到开发环境中感觉还是较为麻烦的，这里记录一下自己的折腾过程。\n\n## 环境说明\n本文主要围绕使用IDEA Community进行Spring Boot应用的开发做记录，在网上查找资料时感觉IDEA不同版本下对Docker的使用差别还蛮大的，毕竟Docker也是这几年才快速发展的技术，IDE厂商们跟进肯定也不是一步到位的，前期坑也不少，如果想在不同版本尝试体验的话，我会推荐你直接查看IDEA官方的Guide。\n本文涉及的工具版本等如下：\n* IDEA Community 2020.1.1   \n  （安装好Docker和Spring插件）\n* Docker 19.03.8\n* docker-compose 1.25.4\n\n## 目标效果\n首先是程序，主要想实践一个每次访问后递增数字的Restful的接口，数字存在Redis容器中；  \n开发效果上当然想尽量能够跟直接在本地开发一样，包括热更新等的使用体验。\n\n## 程序的运行环境完全使用Docker\n### 文件准备\nDemo的代码可以查看我的[Github仓库](https://github.com/zhaozecheng/spring-docker-debug-demo)。\n1. Java程序  \n首先先通过Spring Assistant插件创建一个Spring Boot项目，勾选上web，Redis和devtool等需要的依赖后，实现我需要的程序如下： \n    ```java\n    @RestController\n    @RequestMapping(\"/demo\")\n    public class DemoController {\n\n        @Autowired\n        private StringRedisTemplate stringRedisTemplate ;\n\n        private final String KEY = \"demo-key\";\n\n        @GetMapping(\"/increase\")\n        public String increase() {\n            String result;\n\n            if (stringRedisTemplate.hasKey(KEY)) {\n                String val = stringRedisTemplate.opsForValue().get(KEY);\n                result = (Integer.parseInt(val) + 1) + \"\";\n                stringRedisTemplate.opsForValue().set(KEY, result);\n            } else {\n                stringRedisTemplate.opsForValue().set(KEY, \"1\");\n                result = \"1\";\n            }\n            return result;\n        }\n    }\n    ```\n\n1. 创建Dockerfile  \n创建一个Dockerfile，拷贝项目后执行`mvn packge`打包：\n\n    ```dockerfile\n    FROM openjdk:11\n\n    COPY . /project\n    RUN apt-get update \\\n        && apt-get install -y maven \\\n        && cd /project \\\n        && mvn package\n\n    CMD [\"java\", \"-jar\", \"/project/target/docker-debug-demo-0.0.1-SNAPSHOT.jar\"]\n    ```\n\n1. 创建docker-compose.yml  \n创建docker-compose文件，主要包含执行jar包的app容器和redis容器\n    ```yml\n    version: '3'\n\n    services:\n    app:\n        build:\n        context: .\n        dockerfile: Dockerfile\n        ports:\n        - \"8080:8080\"\n        depends_on:\n        - redis\n        command: java -jar /project/target/docker-debug-demo-0.0.1-SNAPSHOT.jar\n\n    redis:\n        image: redis:5-alpine\n        ports:\n        - \"6379:6379\"\n        command: redis-server\n    ```\n\n1. Spring配置文件  \n因为运行在Docker上，`application.yml`上redis的host填入redis容器的名称。\n    ```yml\n    spring:\n        redis:\n            database: 0\n            host: redis\n            port: 6379\n\n    ```\n\n### 运行程序\n安装好Docker插件后在`docker-compose.yml`文件左侧会有启动和debug图标，直接启动跟用`docker-compose up`差不多，下面记录一下debug启动。\n\n1. 启动参数配置\n\n    点击`docker-compose.yml`文件左侧的debug图标后，在出现的面板上勾选上当前模块，然后双击下面的launch编辑docker的启动参数。  \n    关键在于`-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005`这个参数，它的作用是指定JVM开启调试端口，后面踩坑记录里也会涉及到它。\n    > 如果JDK是8或者之前的版本，address的值改成5005，即`address=5005`  \n\n\n    ![启动面板配置](/img/in-post/20200516_spring_docker_debug/run-configuration.jpg)\n    <center>启动面板配置</center>\n\n    ![编辑Docker启动参数](/img/in-post/20200516_spring_docker_debug/configure-docker.jpg)\n    <center>编辑Docker启动参数</center>\n\n1. Debug模式启动\n\n    编辑好启动器后可以直接点击点击`docker-compose.yml`文件左侧的debug图标启动程序，不过因为会重新创建容器，所以如果已经有容器在运行的话要先停止运行并删除。\n\n    ![启动程序](/img/in-post/20200516_spring_docker_debug/startup.jpg)\n    <center>点击启动程序</center>\n\n    ![启动成功](/img/in-post/20200516_spring_docker_debug/starting-success.jpg)\n    <center>启动成功</center>\n\n1. 访问程序\n    \n    启动后通过`http://localhost:8080/demo/increase`连续访问接口，递增的接口便完成了。\n\n    ![第一次访问](/img/in-post/20200516_spring_docker_debug/access1.jpg)\n    <center>第一次访问</center>\n\n    ![第二次访问](/img/in-post/20200516_spring_docker_debug/access2.jpg)\n    <center>第二次访问</center>\n\n1. 调试程序\n\n    这个时候已经可以正常打断点和调试程序了。\n\n    ![设置断点](/img/in-post/20200516_spring_docker_debug/set-breakpoint.jpg)\n    <center>设置断点</center>\n\n    ![进入断点](/img/in-post/20200516_spring_docker_debug/debug-application.jpg)\n    <center>访问接口进入断点</center>\n\n1. 热部署\n\n    如果事先引入了`devtools`依赖的话，热部署也是可以直接用的（需要重新编译）。\n\n    ![修改程序递增值为2](/img/in-post/20200516_spring_docker_debug/change-code.jpg)\n    <center>修改程序递增值为2</center>\n\n    ![重新编译后日志](/img/in-post/20200516_spring_docker_debug/event-log.jpg)\n    <center>重新编译后日志</center>\n\n    ![修改后第一次访问](/img/in-post/20200516_spring_docker_debug/access3.jpg)\n    <center>修改后第一次访问</center>\n\n    ![修改后第二次访问](/img/in-post/20200516_spring_docker_debug/access4.jpg)\n    <center>修改后第二次访问</center>\n\n    可以看到递增值变成了2，这里容器并没有重新启动的，不过如果修改配置文件或者依赖文件的话就需要重启容器或者重新build了，这个还是相对麻烦的。\n\n\n## 踩坑记录\n### 遇到`handshake failed - connection prematurally closed`  \n\n在启动容器的时候有遇到启动不成功，报一下log的情况：  \n\n```\n10:21\tError running 'Remote with compose': Unable to open debugger port (localhost:5005): java.io.IOException \"handshake failed - connection prematurally closed\"\n```  \n\n网上查了下发现引起这个错误的可能还是蛮多的，从最常见的启动命令行写错到本地JVM版本与Docker容器JVM版本不同，好几种都有。\n\n不过上面这些原因在我自己身上都不适用，调查时候发现容器都是成功启动的，容器的调试端口（5005）也是运行着的。\n于是通过`docker exec`进入容器用，发现5005端口并没有被监听，于是怀疑jar包运行时候`-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005`没有生效。\n\n于是退出容器适用`docker inspect`查看容器信息，发现启动参数确实很奇怪：\n    \n![docker inspect查看启动参数](/img/in-post/20200516_spring_docker_debug/docker-inspect1.jpg)\n<center>docker inspect查看启动参数</center>\n\n查找到这里就基本知道原因了，IDEA的Docker启动器上配置的启动调试端口的命令行被覆盖或者说拼接在一个没有启动调试端口的命令行后面，导致后面连接调试端口失败。然后我查看当时的Dockerfile，发现当时的代码如下：\n\n```dockerfile\nFROM openjdk:11\n\nCOPY . /project\nRUN apt-get update \\\n    && apt-get install -y maven \\\n    && cd /project \\\n    && mvn package\n\nENTRYPOINT [\"java\", \"-jar\", \"/project/target/docker-debug-demo-0.0.1-SNAPSHOT.jar\"]\n```\n\n跟上面的Dockerfile不同的地方在于当时根据[官方DEMO](https://github.com/IdeaUJetBrains/SpringBootDockerDemoDebug/blob/master/Dockerfile)学习，执行默认命令的时候用了`ENTRYPOINT`而不是`CMD`，而在`docker-compose.yml`文件的代码如下：\n```yml\nversion: '3'\n\nservices:\napp:\n    build:\n    context: .\n    dockerfile: Dockerfile\n    ports:\n    - \"8080:8080\"\n    depends_on:\n    - redis\n    command: java -jar /project/target/docker-debug-demo-0.0.1-SNAPSHOT.jar\n\n...\n...\n...\n```\n这里用的是`command`命令，因为Dockerfile和docker-compose.yml文件的命令基本是一致的，所以我去看了下docker-compose.yml文档，发现确实有[entrypoint](https://docs.docker.com/compose/compose-file/#entrypoint)参数，并且有下面这段Note：\n```\nSetting entrypoint both overrides any default entrypoint set on the service’s image with the ENTRYPOINT Dockerfile instruction, and clears out any default command on the image - meaning that if there’s a CMD instruction in the Dockerfile, it is ignored.\n```\n而[command](https://docs.docker.com/compose/compose-file/#command)上并没有类似的Note，这说明docker-compose.yml文件的`entrypoint`可以覆盖Dockerfile的`CMD`，但`command`应该是没法覆盖Dockerfile的`ENTRYPOINT`的，于是通过将Dockerfile的`ENTRYPOINT`改成`CMD`，果然可以正常执行了。\n\n![docker inspect查看启动参数](/img/in-post/20200516_spring_docker_debug/docker-inspect2.jpg)\n<center>修改后通过docker inspect查看启动参数</center>\n\n写这个Demo时候我都是参考官方Demo的代码来写的（后来试着跑官方Demo也有同样问题），算是踩了官方的坑，不过也是有自己对Docker还不太熟悉的原因吧。\n\n## 写在后面\nIDEA对于Docker的支持总体来讲还算成熟，但用的时候还是有一些不太舒服的地方，比如修改依赖或者配置等后需要重新打包镜像，应用的调试信息没法在IDEA的控制台查看，还时不时可能有一些小坑等等。但好处也是一样的，随着Java大版本发布频率变高，可能个人开发环境需要多个版本JDK的情况会变多，那么用Docker隔离环境还是很舒服的，特别是对我这样强迫症而言，我现在都有把本地机器各种环境都搬上Docker的冲动了。\n\n## 参考\n* [Run and debug a Spring Boot application using Docker Compose](https://www.jetbrains.com/help/idea/run-and-debug-a-spring-boot-application-using-docker-compose.html)  \n* [SpringBootDockerDemoDebug](https://github.com/IdeaUJetBrains/SpringBootDockerDemoDebug)\n* [ntelliJ IDEAからDocker上で動くSprint Bootアプリにdebuggerをつなぐ](https://www.sys1yagi.com/entry/2019/04/04/165234)","tags":["Docker","折腾"]}]